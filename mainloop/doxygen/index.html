<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>mainloop: Main Page</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.7 -->
<div class="qindex"><a class="qindexHL" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>mainloop Documentation</h1>
<p>
Most programs are built around some variation of a main loop. In it's simplest form, this looks something like<p>
<pre><div class="fragment"> while ((len = read(fdin, buf, sizeof(buf)) != -1) {
	...
	write(fdout, buf, len);
 }
</div></pre><p>
As the program evolves, non-blocking (or even async) I/O, timers, and signal handling are added. Soon, you either add some sort of generic framework, or you end up with an unmaintainable mess.<p>
And even though (with some experience) you can write such a framework rather quickly, it still takes a considerable amount of time. The result usually lacks both uniformity (it is rewritten every time) and generality (it is often "optimized" for a specific case).<p>
If you know your program is going to grow beyond the simple case outlined above, it pays of to use a generic framework like glib. This is not meant to imply that the glib implementation is better than what you would write instead (IMHO glib is tied too much to the structure of the poll() syscall and can't be adapted to take advantage of other mechanisms like /dev/poll, epoll or kqueue). But it is good enough, and above all, it's widely used and documented.<p>
An additional advantage of using a standardized framework is that it (at least theoretically, because it only works if everyone uses the same framework) solves the problem of competing signal handlers in libraries.<p>
The following (simple minded) code metric shows that while you may feel that you have to write a lot of code just to accomodate the glib framework, you actually write less (because you don't have to write the framework itself). In any case it shows that the difference is not big enough to be used as an argument.<p>
<pre><div class="fragment"> Stmts Comnts  Funcs  Blanks Lines
   195    109      8     46    550 bad/mainloop_bad.c
   245    163     24     62    772 good/mainloop_good.c
   226    132     20     84    715 glib/mainloop_glib.c
</div></pre><p>

The three example programs can be looked at here:
 - @ref mainloop_bad.c
 - @ref mainloop_good.c
 - @ref mainloop_glib.c

They have been tested on Solaris 8 using glib 2.4.0 and gcc 3.4.0 (and
nothing else, though they should be easily portable to any modern unix).

The whole archive (including makefiles and documentation) can be
downloaded as tar file: <a href="mainloop.tar.gz">mainloop.tar.gz</a>

This documentation is available as pdf: <a href="mainloop.pdf">mainloop.pdf</a>

The source code is available as postscript (for printing): <a href="mainloop.ps">mainloop.ps</a>
<p>
Doxygen cannot cope with multiply defined (local) symbols. Local symbols having the same name are documented only once, with all links pointing to the same file. <hr size="1"><address style="align: right;"><small>Generated on Mon Jul 19 16:02:06 2004 for mainloop by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 ></a> 1.3.7 </small></address>
</body>
</html>
